---
title: "NotebookR"
author: "Elsa Danh-Nghet"
date: "2024-03-16"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(reshape2)
library(gridExtra)
library(factoextra)
library(FactoMineR)
library(plotly)
library(ggmap)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r file}
load <- read.csv("data/velibLoading.csv", sep=" ") # Reading data of the Velib loading
head(load)
str(load)


```
```{r}
coord = read.csv('data/velibCoord.csv', sep = " ") # Reading coordinates for each loading
head(coord)
str(coord)
```


```{r }
cat('Shape of "load" :', dim(load))
number_of_missing_values_load <- sum(is.na(load))
number_of_duplicate_values_load <- sum(duplicated(load))
cat('\nNumber of missing values "load"', number_of_missing_values_load)
cat('\nNumber of duplicate values "load":', number_of_duplicate_values_load)

cat('\nShape of "coord" :', dim(coord))
number_of_missing_values_coord <- sum(is.na(coord))
number_of_duplicate_values_coord <- sum(duplicated(coord))
cat('\nNumber of missing values "coord"', number_of_missing_values_coord)
cat('\nNumber of duplicate values "coord":', number_of_duplicate_values_coord)

```
```{r}
station_names <- table(coord$names)
station_names <- sort(station_names,decreasing=TRUE)
head(station_names)
indexes <- which(station_names>1)
print(station_names[indexes])
cat("\nNumber of stations with multiple occurences in coord:", length(station_names[indexes]))
```


```{r}
name_checkup <- c(' PORTE DES LILAS', ' CLICHY')
multiple_stat <- coord$names %in% name_checkup
stat_rel <- coord[multiple_stat,]
print(stat_rel)
```


```{r}
fig <- qmplot(data=stat_rel, longitude, latitude, color = names, zoom = 16) + 
    labs(title = paste('Placement of stations with multiple occurances:',paste(name_checkup, collapse = ',')))
fig
```


```{r}
time_ticks <- seq(0,168, by = 24)

options(repr.plot.width = 15, repr.plot.height = 6)
bp <- boxplot(load, xlab = "Time", ylab = "Loading", col = "blue", medcol ="violet")
abline(v = time_ticks, col = "orange", lwd = 4, lty = "dotted")
```
```{r}
print('--- Average loading ---')
mean <- rowMeans(load) # Average per station
tot_mean <- mean(mean)
print(round(tot_mean,4))

# --- #
print(" ")
print('--- Least loaded station, on average ---')
print(paste(coord[which.min(mean),],round (min(mean),4)))
# --- 

print('')

print('--- Fullest loaded station, on average ---')
print(paste(coord[which.max(mean),],round (max(mean),4)))
```
```{r}
options(repr.plot.width = 15, repr.plot.height = 6)   # Comme plt.figure(15, 6)

# --- #

time_tick = 1 + 24*(0:6)  # vector corresponding to the beginning of days

# select a station
ind <- which(coord$names == " PORTE DES LILAS")
i1 <- ind[1]
# Fetches a vector of ints of size & from index 1 to n_row(loading) 

df = melt(load[i1,])  #the function melt reshapes it from wide to long (like np.reshape?)
df$time_range = 1:ncol(load)

p1 = ggplot(df, aes(x=time_range, y=value)) + geom_line(col="darkorchid") +
    geom_vline(xintercept=time_tick, col="orange", linetype="dashed") +
    labs(title=coord$names[i1])

i2 <- ind[2]
# Fetches a vector of ints of size & from index 1 to n_row(loading) 

df = melt(load[i2,])  #the function melt reshapes it from wide to long (like np.reshape?)
df$time_range = 1:ncol(load)

p2 = ggplot(df, aes(x=time_range, y=value)) + geom_line(col="darkorchid") +
    geom_vline(xintercept=time_tick, col="orange", linetype="dashed") +
    labs(title=coord$names[i2])

i3 <- ind[3]
# Fetches a vector of ints of size & from index 1 to n_row(loading) 

df = melt(load[i3,])  #the function melt reshapes it from wide to long (like np.reshape?)
df$time_range = 1:ncol(load)

p3 = ggplot(df, aes(x=time_range, y=value)) + geom_line(col="darkorchid") +
    geom_vline(xintercept=time_tick, col="orange", linetype="dashed") +
    labs(title=coord$names[i3])

p <- list(p1,p2,p3)
do.call(grid.arrange,p)

```
```{r}
mean_per_hour_per_day = colMeans(load)
mean_per_hour_per_day = matrix(mean_per_hour_per_day, nrow = 24)
mean_per_hour         = rowMeans(mean_per_hour_per_day)

# --- #

mean_per_hour_per_day            = as.data.frame(mean_per_hour_per_day)
colnames(mean_per_hour_per_day)  = list("Monday", "Tuesday", "Wednesday","Thursday", "Friday", "Saturday", "Sunday")
mean_per_hour_per_day$time_range = c(1:24)
mean_per_hour_per_day            = melt(mean_per_hour_per_day, id='time_range', variable.name='Days')

mean_per_hour            = as.data.frame(mean_per_hour)
colnames(mean_per_hour)  = list("Weekly")
mean_per_hour$time_range = c(1:24)

# --- #

options(repr.plot.width = 15, repr.plot.height = 10)

ggplot() + 
    geom_line(data=mean_per_hour_per_day, aes(x=time_range, y=value, color=Days)) + 
    geom_line(data=mean_per_hour, aes(x=time_range, y=Weekly), linewidth = 1.5)
```

```{r}
options(repr.plot.width = 13, repr.plot.height = 10)
hours = c(6, 12, 23)

dfi = coord
p = list()
for (i in 1:length(hours)){
    dfi$load = load[,hours[i]]
    p[[i]] = ggplot(dfi, aes(x=longitude, y=latitude, color=load)) + 
        geom_point() +
        labs(title = paste("Stations loading - Monday",hours[i],"h"))
}

do.call(grid.arrange,c(p, ncol=2))
```
On peut voir que Le matin et le soir, les stations les plus remplies sont aux extérieures tandis qu'au milieu de la journée, ils sont au centre (le long de la Seine)
